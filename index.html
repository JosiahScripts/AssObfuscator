<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Lua Obfuscator</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 200px; margin-bottom: 10px; font-family: monospace; }
    button { padding: 10px; font-size: 16px; }
  </style>
</head>
<body>
  <h1>Lua Obfuscator (Client-side)</h1>
  <textarea id="inputLua" placeholder="Enter Lua source code here"></textarea>
  <button id="obfuscateBtn">Obfuscate & Download</button>
  <textarea id="outputLua" readonly placeholder="Obfuscated Lua code will appear here"></textarea>

  <script>
    // Random name generator for obfuscated identifiers
    function randName(len) {
      len = len || Math.floor(Math.random()*5 + 3);
      let s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
      let result = s.charAt(Math.floor(Math.random()*s.length));
      s += '0123456789_';
      for (let i=1; i<len; i++) {
        result += s.charAt(Math.floor(Math.random()*s.length));
      }
      return result;
    }

    // Main obfuscation function
    function obfuscateLua() {
      const input = document.getElementById('inputLua').value;
      if (!input) { alert('Enter Lua code'); return; }

      // 1. Generate random XOR key
      const keyChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let key = '';
      const keyLen = Math.floor(Math.random()*5) + 5;
      for (let i = 0; i < keyLen; i++) {
        key += keyChars.charAt(Math.floor(Math.random() * keyChars.length));
      }

      // 2. XOR-encrypt the input
      let xorChars = [];
      for (let i = 0; i < input.length; i++) {
        xorChars.push(String.fromCharCode(input.charCodeAt(i) ^ key.charCodeAt(i % key.length)));
      }

      // 3. Base64 encode the XOR result
      let b64 = btoa(xorChars.join(''));

      // 4. Compute checksums for anti-tamper
      let sumB64 = 0, sumOrig = 0;
      for (let i = 0; i < b64.length; i++) {
        sumB64 = (sumB64 + b64.charCodeAt(i)) % 65536;
      }
      for (let i = 0; i < input.length; i++) {
        sumOrig = (sumOrig + input.charCodeAt(i)) % 65536;
      }

      // 5. Generate random names for Lua variables/functions
      const varB64 = randName();
      const varKey = randName();
      const varAlpha = randName();
      const funcDec = randName();
      const funcXor = randName();
      const bufVar = randName();
      const loadVar = randName();

      // 6. Build the Lua decoding stub (as one long string)
      //    - Includes the comment credit, Base64 payload, key, alphabet, decode functions, and anti-tamper checks.
      let stub = '--[[ PROTECTED BY REO ]]--'
        + 'local ' + varB64 + '="' + b64 + '";'
        + 'local ' + varKey + '="' + key + '";'
        + 'local ' + varAlpha + '="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";'
        + 'local function ' + funcDec + '(t)local r={};local i=1;'
        + 'while i<=#t do '
        +   'local a=' + varAlpha + ':find(t:sub(i,i),1,true)-1;'
        +   'local b=' + varAlpha + ':find(t:sub(i+1,i+1),1,true)-1;'
        +   'local c=' + varAlpha + ':find(t:sub(i+2,i+2),1,true)-1;'
        +   'local d=' + varAlpha + ':find(t:sub(i+3,i+3),1,true)-1;'
        +   'local n=a*2^18 + b*2^12 + c*2^6 + d;'
        +   'local x=math.floor(n/2^16)%256;'
        +   'local y=math.floor(n/2^8)%256;'
        +   'local z=n%256;'
        +   'r[#r+1]=string.char(x);'
        +   'if t:sub(i+2,i+2)~="=" then r[#r+1]=string.char(y) end;'
        +   'if t:sub(i+3,i+3)~="=" then r[#r+1]=string.char(z) end;'
        +   'i=i+4;'
        + 'end;return table.concat(r)end;'
        + 'local function ' + funcXor + '(a,b)local res=0;for k=0,7 do '
        +   'local aa=a%2; local bb=b%2;'
        +   'if aa~=bb then res=res+2^k end;'
        +   'a=math.floor(a/2); b=math.floor(b/2);'
        + 'end;return res end;'
        + 'local sum=0; for i=1,#' + varB64 + ' do sum=(sum+' + varB64 + ':byte(i))%65536 end;'
        + 'if(sum~=' + sumB64 + ')then return end;'
        + 'local tmp=' + funcDec + '(' + varB64 + ');'
        + 'local ' + bufVar + '={};'
        + 'for i=1,#tmp do '
        +   bufVar + '[#' + bufVar + '+1]=string.char(' + funcXor + '(tmp:byte(i),' + varKey + ':byte((i-1)%#' + varKey + '+1)));'
        + 'end;'
        + 'local script=table.concat(' + bufVar + ');'
        + 'local sum2=0; for i=1,#script do sum2=(sum2+script:byte(i))%65536 end;'
        + 'if(sum2~=' + sumOrig + ')then return end;'
        + 'local ' + loadVar + '=(loadstring or load);'
        + loadVar + '(script)();';

      // 7. (Optional) Insert junk code before stub (not shown here for brevity).
      //    This could be done by prepending random 'local ...', 'if ... then ... end;' blocks to 'stub'.

      // 8. Output and download
      document.getElementById('outputLua').value = stub;
      const blob = new Blob([stub], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'obfuscated.lua';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Hook up the button
    document.getElementById('obfuscateBtn').addEventListener('click', obfuscateLua);
  </script>
</body>
</html>
